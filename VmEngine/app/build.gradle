plugins {
    // Android 应用模块插件（使用版本目录中的别名）。
    alias(libs.plugins.androidApplication)
}

// 工程根目录：当前模块在 VmEngine/app，下一级父目录是 VmEngine，再上一级是总工程根。
def vmpProjectRoot = rootProject.projectDir.parentFile
// 是否启用 VmProtect 管线（默认关闭，避免普通开发受影响）。
def vmpEnabled = ((project.findProperty("vmpEnabled") ?: "false").toString().toBoolean())
// 启用后是否自动构建 VmProtect.exe。
def vmpAutoBuildTool = ((project.findProperty("vmpAutoBuildTool") ?: "false").toString().toBoolean())
// VmProtect 工具路径，可被 -PvmpToolExe 覆盖。
def vmpToolExe = file((project.findProperty("vmpToolExe")
        ?: "${vmpProjectRoot}/VmProtect/cmake-build-debug/VmProtect.exe").toString())
// 输入 so 覆盖路径（默认自动解析 demo 中间产物）。
def vmpInputSoOverride = (project.findProperty("vmpInputSo") ?: "").toString().trim()
// VmProtect CMake 项目目录。
def vmProtectProjectDir = file("${vmpProjectRoot}/VmProtect")
// VmProtect 默认构建目录。
def vmProtectBuildDir = file("${vmProtectProjectDir}/cmake-build-debug")
// patch origin so 覆盖路径（默认沿用 vmpInputSo）。
def vmpPatchOriginSoOverride = (project.findProperty("vmpPatchOriginSo") ?: "").toString().trim()
// 用户通过 -PvmpFunctions 传入逗号分隔函数列表（可选覆盖）。
def vmpFunctionsRaw = (project.findProperty("vmpFunctions") ?: "").toString().trim()
// VmProtect 输出目录（中间产物）。
def vmpOutputDir = file("$buildDir/generated/vmprotectOut")
// 最终写入 APK 的 assets 目录。
def vmpAssetsDir = file("src/main/assets")

def parseVmpFunctions = {
    // 未指定函数时返回空列表（由调用方决定回退策略）。
    if (vmpFunctionsRaw.isEmpty()) {
        return []
    }
    // 解析逗号列表，去空白并去除空项。
    return vmpFunctionsRaw.split(",")
            .collect { it.trim() }
            .findAll { !it.isEmpty() }
}

def resolveReadelfExe = {
    // 优先使用工程根目录下固定 readelf.exe，未命中再回退 PATH。
    def candidates = [
            file("${vmpProjectRoot}/readelf.exe"),
    ]
    def hit = candidates.find { it.exists() }
    return hit != null ? hit.absolutePath : "readelf"
}

def collectAllDemoFunctionsFromSo = { File soFile ->
    // 通过 readelf 读取符号表，自动收集 demo 业务函数（fun_*）。
    def readelfExe = resolveReadelfExe()
    def stdout = new ByteArrayOutputStream()
    def stderr = new ByteArrayOutputStream()
    exec {
        commandLine readelfExe, "-Ws", soFile.absolutePath
        standardOutput = stdout
        errorOutput = stderr
        ignoreExitValue = false
    }

    // 用 LinkedHashSet 保证去重且保序。
    def names = new LinkedHashSet<String>()
    stdout.toString("UTF-8").eachLine { line ->
        def trimmed = line.trim()
        // 仅处理符号行（格式类似："123: ... FUNC ... name"）。
        if (trimmed ==~ /^\d+:.*/) {
            // 最多切 8 段，最后一段保留完整符号名。
            def parts = trimmed.split(/\s+/, 8)
            if (parts.length >= 8) {
                def symType = parts[3]
                def symNdx = parts[6]
                def symName = parts[7]
                // 仅纳入已定义的 demo 业务函数：fun_*。
                if (symType == "FUNC"
                        && symNdx != "UND"
                        && symNdx != "ABS"
                        && symName != null
                        && !symName.isEmpty()
                        && symName.startsWith("fun_")) {
                    names.add(symName)
                }
            }
        }
    }
    return new ArrayList<String>(names)
}

def resolveCmakeExe = {
    // 优先使用团队机器常见安装路径，未命中时回退到 PATH 中的 cmake。
    def candidates = [
            file("C:/Program Files/JetBrains/CLion 2022.2.5/bin/cmake/win/bin/cmake.exe"),
            file("D:/Clion2022/bin/cmake/win/bin/cmake.exe"),
    ]
    def hit = candidates.find { it.exists() }
    return hit != null ? hit.absolutePath : "cmake"
}

def resolveNinjaExe = {
    // 与 cmake 同理，优先固定路径，回退 PATH。
    def candidates = [
            file("C:/Program Files/JetBrains/CLion 2022.2.5/bin/ninja/win/ninja.exe"),
            file("D:/Clion2022/bin/ninja/win/ninja.exe"),
    ]
    def hit = candidates.find { it.exists() }
    return hit != null ? hit.absolutePath : "ninja"
}

def resolveVmengineSoForDebug = {
    // 从 AGP 产物目录中定位“最新”的 debug libvmengine.so。
    def candidates = []
    def cxxDebugRoot = file("$buildDir/intermediates/cxx/Debug")
    if (cxxDebugRoot.exists()) {
        cxxDebugRoot.eachDir { dir ->
            def so = new File(dir, "obj/arm64-v8a/libvmengine.so")
            if (so.exists()) {
                candidates.add(so)
            }
        }
    }
    def cmakeFallback = file("$buildDir/intermediates/cmake/debug/obj/arm64-v8a/libvmengine.so")
    if (cmakeFallback.exists()) {
        candidates.add(cmakeFallback)
    }
    // 找不到产物时返回 null，让调用方抛更明确异常。
    if (candidates.isEmpty()) {
        return null
    }
    // 取最后修改时间最新的一个，规避多变体并存时选错。
    candidates.sort { a, b -> Long.compare(b.lastModified(), a.lastModified()) }
    return candidates[0]
}

def resolveDemoOriginSoForVmp = {
    // 默认从 demo 工程中间产物查找 libdemo.so。
    def candidates = []
    def cxxDebugRoot = file("${vmpProjectRoot}/demo/app/build/intermediates/cxx/Debug")
    if (cxxDebugRoot.exists()) {
        cxxDebugRoot.eachDir { dir ->
            def so = new File(dir, "obj/arm64-v8a/libdemo.so")
            if (so.exists()) {
                candidates.add(so)
            }
        }
    }
    def cmakeFallback = file("${vmpProjectRoot}/demo/app/build/intermediates/cmake/debug/obj/arm64-v8a/libdemo.so")
    if (cmakeFallback.exists()) {
        candidates.add(cmakeFallback)
    }

    // 未找到返回 null，由调用方报错。
    if (candidates.isEmpty()) {
        return null
    }
    // 先按时间排序，优先评估最新产物。
    candidates.sort { a, b -> Long.compare(b.lastModified(), a.lastModified()) }
    // 选择“确实包含 fun_* 导出”的输入 so，避免误选到已被覆盖的受保护库。
    for (candidate in candidates) {
        try {
            def functions = collectAllDemoFunctionsFromSo(candidate)
            if (functions != null && !functions.isEmpty()) {
                return candidate
            }
        } catch (Exception ignored) {
            // 读符号失败时继续尝试下一个候选。
        }
    }
    // 兜底返回最新文件，由后续逻辑给出更明确错误。
    return candidates[0]
}

def resolveVmpInputSo = {
    // 显式覆盖优先。
    if (vmpInputSoOverride != null && !vmpInputSoOverride.isEmpty()) {
        return file(vmpInputSoOverride)
    }
    // 默认使用 demo 中间产物。
    return resolveDemoOriginSoForVmp()
}

def resolveVmpPatchOriginSo = {
    // 显式覆盖优先。
    if (vmpPatchOriginSoOverride != null && !vmpPatchOriginSoOverride.isEmpty()) {
        return file(vmpPatchOriginSoOverride)
    }
    // 默认与 input-so 保持一致。
    return resolveVmpInputSo()
}

tasks.register("buildVmProtectTool") {
    // Gradle 自定义任务：构建主机端 VmProtect.exe。
    group = "vmp"
    description = "Configure and build VmProtect.exe"
    // 声明输出文件，便于任务可视化。
    outputs.file(vmpToolExe)
    // 每次都执行，确保拿到最新 C++ 逻辑。
    outputs.upToDateWhen { false }
    // 仅在启用 vmp 且允许自动构建时执行。
    onlyIf { vmpEnabled && vmpAutoBuildTool }
    doLast {
        def cmakeExe = resolveCmakeExe()
        def ninjaExe = resolveNinjaExe()
        // 首次构建前确保 build 目录存在。
        if (!vmProtectBuildDir.exists()) {
            vmProtectBuildDir.mkdirs()
        }
        def cmakeCache = file("${vmProtectBuildDir}/CMakeCache.txt")
        // 首次没有 cache 时先 configure。
        if (!cmakeCache.exists()) {
            exec {
                commandLine cmakeExe,
                        "-G", "Ninja",
                        "-S", vmProtectProjectDir.absolutePath.replace("\\", "/"),
                        "-B", vmProtectBuildDir.absolutePath.replace("\\", "/"),
                        "-DCMAKE_BUILD_TYPE=Debug",
                        "-DCMAKE_MAKE_PROGRAM=${ninjaExe.replace('\\', '/')}"
                workingDir vmProtectProjectDir
            }
        }
        // 执行 build，目标固定为 VmProtect 可执行文件。
        exec {
            commandLine cmakeExe,
                    "--build", vmProtectBuildDir.absolutePath,
                    "--target", "VmProtect",
                    "-j", "12"
            workingDir vmProtectProjectDir
        }
    }
}

tasks.register("runVmProtectPipelineDebug") {
    // Gradle 自定义任务：执行 route4 流程并产出受保护主机库。
    group = "vmp"
    description = "Run VmProtect.exe to export assets and produce final protected libvmengine_patch.so (debug)."
    // 必须先有 debug native 产物和可执行工具。
    dependsOn("externalNativeBuildDebug", "buildVmProtectTool")
    outputs.dir(vmpOutputDir)
    outputs.dir(vmpAssetsDir)
    outputs.upToDateWhen { false }
    onlyIf { vmpEnabled }
    doLast {
        // 解析当前最新 debug libvmengine.so 作为 host 输入。
        def hostSo = resolveVmengineSoForDebug()
        if (hostSo == null || !hostSo.exists()) {
            throw new GradleException("debug libvmengine.so not found under app/build/intermediates")
        }
        // 解析 vmp 输入与 patch origin so。
        def vmpInputSo = resolveVmpInputSo()
        def vmpPatchOriginSo = resolveVmpPatchOriginSo()
        // 约定 patch 产物固定输出为 libvmengine_patch.so，避免覆盖原始 libvmengine.so。
        def protectedHostSo = new File(hostSo.parentFile, "libvmengine_patch.so")
        if (!vmpToolExe.exists()) {
            throw new GradleException(
                    "VmProtect.exe not found: ${vmpToolExe}. " +
                            "Build it first, or run with -PvmpAutoBuildTool=true")
        }
        if (vmpInputSo == null || !vmpInputSo.exists()) {
            throw new GradleException(
                    "vmp input so not found. Build demo first to produce libdemo.so, " +
                            "or pass -PvmpInputSo=<path>")
        }
        if (vmpPatchOriginSo == null || !vmpPatchOriginSo.exists()) {
            throw new GradleException(
                    "vmp patch origin so not found. Build demo first, " +
                            "or pass -PvmpPatchOriginSo=<path>")
        }
        // 函数选择策略：
        // 1) 优先使用 -PvmpFunctions 显式列表；
        // 2) 未显式指定时，从 input-so 自动提取全部 fun_* 并显式展开为 --function。
        def selectedFunctions = parseVmpFunctions()
        if (selectedFunctions.isEmpty()) {
            selectedFunctions = collectAllDemoFunctionsFromSo(vmpInputSo)
        }
        if (selectedFunctions.isEmpty()) {
            throw new GradleException(
                    "no demo functions found in ${vmpInputSo}. " +
                            "Pass -PvmpFunctions=fun_add,fun_for,... to override")
        }
        println("[VMP] selected functions (${selectedFunctions.size()}): ${selectedFunctions.join(', ')}")

        // 清理并重建输出目录，避免遗留旧文件。
        if (vmpOutputDir.exists()) {
            delete vmpOutputDir
        }
        vmpOutputDir.mkdirs()
        vmpAssetsDir.mkdirs()

        def cmd = [
                // 外部工具路径。
                vmpToolExe.absolutePath,
                // 显式路线模式：加固全流程。
                "--mode", "protect",
                // route4 必填参数：输入 so 与输出目录。
                "--input-so", vmpInputSo.absolutePath,
                "--output-dir", vmpOutputDir.absolutePath,
                // 输出扩展 so 与分支地址表文件名。
                "--expanded-so", "libdemo_expand.so",
                "--shared-branch-file", "branch_addr_list.txt",
                // 产物报告路径。
                "--coverage-report", "coverage_report.md",
                // vmengine so 与最终输出 so。
                "--vmengine-so", hostSo.absolutePath,
                "--output-so", protectedHostSo.absolutePath,
                // patch origin（entry-dispatch 模式由 VmProtect 内部固定）。
                "--patch-origin-so", vmpPatchOriginSo.absolutePath,
        ]
        selectedFunctions.each { fn ->
            // 加固函数列表：由 -PvmpFunctions 显式给出。
            cmd.addAll(["--function", fn])
        }

        println("[VMP] running: ${cmd.join(' ')}")

        System.println("cmd:" + cmd)
        exec {
            commandLine cmd
            workingDir vmpProjectRoot
        }

        // 用加固产物覆盖 host so，确保 App 运行时加载的是“已加固版本”。
        if (!protectedHostSo.exists()) {
            throw new GradleException("protected host so not found: ${protectedHostSo}")
        }
        copy {
            from(protectedHostSo)
            into(hostSo.parentFile)
            rename { "libvmengine.so" }
        }

        // 删除旧 assets 中对应文件，确保拷贝结果是“本轮唯一版本”。
        delete(fileTree(vmpAssetsDir) {
            include "branch_addr_list.txt"
            include "libdemo_expand.so"
            include "fun_*.txt"
            include "fun_*.bin"
        })

        copy {
            // 只把运行时需要的路由文件与函数 payload 拷贝到 assets。
            from(vmpOutputDir) {
                include "branch_addr_list.txt"
                include "libdemo_expand.so"
                include "fun_*.txt"
                include "fun_*.bin"
            }
            into(vmpAssetsDir)
        }
        println("[VMP] protected host so generated: ${protectedHostSo}")
        println("[VMP] protected so installed as runtime host: ${hostSo}")
        println("[VMP] updated assets dir: ${vmpAssetsDir}")
    }
}

android {
    // Android 包名命名空间。
    namespace 'com.example.vmengine'
    // 编译 SDK 版本。
    compileSdk 34

    defaultConfig {
        // 应用 id。
        applicationId "com.example.vmengine"
        // 最低支持版本。
        minSdk 26
        // 目标版本。
        targetSdk 34
        versionCode 1
        versionName "1.0"
        // 当前只构建 arm64，和 VmProtect 能力范围保持一致。
        ndk{
            abiFilters 'arm64-v8a'
        }
        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            // release 当前不做混淆，便于问题定位。
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
    compileOptions {
        // Java 8 语言级别。
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    externalNativeBuild {
        cmake {
            // Native 构建脚本入口。
            path file('src/main/cpp/CMakeLists.txt')
            version '3.22.1'
        }
    }
    buildFeatures {
        // 开启 viewBinding。
        viewBinding true
    }
    packagingOptions {
        jniLibs {
            // Android 14+ 建议在 Gradle 中显式声明 native packaging 行为。
            // route4 依赖稳定的 so 原样打包，这里固定 useLegacyPackaging。
            useLegacyPackaging true
            // route4 需要保留 libvmengine.so 尾部附加 payload，禁止打包阶段 strip 该库。
            keepDebugSymbols += ['**/libvmengine.so']
        }
    }
}

tasks.configureEach { t ->
    // 把 VmProtect 管线插入 debug 打包关键阶段，保证产物实时更新。
    if (t.name == "mergeDebugNativeLibs" || t.name == "mergeDebugAssets") {
        t.dependsOn("runVmProtectPipelineDebug")
    }
}

dependencies {

    // AndroidX 与测试依赖。
    implementation libs.appcompat
    implementation libs.material
    implementation libs.constraintlayout
    testImplementation libs.junit
    androidTestImplementation libs.ext.junit
    androidTestImplementation libs.espresso.core
}

